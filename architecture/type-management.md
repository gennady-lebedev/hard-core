# Type Management
In Rudimental Architecture expected, that Developer made all the types of Commands, Events and Domain entities in preferred language.

But it's not a constraint.
All `Components` can work all the same with runtime-managed objects.
It means, `Types`, their `Fields`, mapping between other `Types` and their `Fields`, `Serialization` and `Deserialization` (`SerDe`) can be managed at runtime in some application.
With domain-separated modules (`Sub-Domains`).

## Type Registry
Holds information about `Types` and `Fields`, mapping between `Types`.

### Types
Filled with `Fields`, `Categories` (mostly marker interfaces) and `Methods` (distant future), unique identified.

Mapping is the key mechanism of transferring `Fields` between different `Types`.

Inheritance allows transfer `Fields`, `Categories` and `Methods` between `Types` in order to structure them.

### Fields
Are strictly typed. Can be any serializable type, but strongly preferred DTO-compatible:
* plain values with various meta about limits and constraints
    * number
    * logical (true/false, y/n, enums)
    * string
    * date and time
* logical and composition
    * self ID
    * reference (ID[T])
    * other DTO
* collection (set, array, map) of any above

Also fields can be marked with some features, like
* optional flag
* autogenerated ID
* security mark (hide passwords)
* privacy mark (censor privacy data, require crypto)
* grants for different user groups
* version of change
* problems mark (something goes wrong and should be fixed)

### Categories
Interfaces with different focus. Interface contains declaration of implementation, requires to provide implementation. Marker Interfaces seems bad practice in SOLID.

But Categories all about Marker Interfaces. It's idea from FP: you can handle behavior linked to that Interface outside. That idea makes Interfaces more like math Categories - marks that Type within some group with same features.

Use cases
* Tx management
* LogLevel (Safe/Unsafe, IO, etc.)
* Auth
* and so on

You get it, all the features Pipeline and Drainage provides.

### Mapping
Bounds at least 2 `Types` as conversion one to another.
Requires every field of output `Type`
* taken and possibly transformed from input `Type`
* or has a default value, possibly with logic to calculate

### Inheritance
In Rudimental architecture, inheritance only one of the mapping between `Types` operators.

### Operators
Because in run-time application `Types` are not limited with static rules of compilation, `Type Management` can provide unique operations above `Types`
* inheritance as factory to produce another `Type`
* generation of `SerDe` in multiple formats, strict usage of `Field` constraints in various systems
* `Versioning` - ability to instantiate multiple `Type Systems` with different changes
* `Impact Analisys` - ability to mark `Types` and `Fields` affected with changes in different `Types` and `Fields` as `Unconsistent`.
Until all `Impact Analisys` issues resolved - version stays `Unconsistent`
* conflict-free multiple inheritance
* manual CRUD (actually DML) operations after inheritance. Requires `Impact Analisys` for stability.
* semantic refactorings as single command. Requires `Impact Analisys` and `Versioning` for filling that single Command.
